% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SMC.R
\name{MIBIS.Z}
\alias{MIBIS.Z}
\title{SMC sampler function using iterated batch importance sampling}
\usage{
MIBIS.Z(
  X,
  y,
  sampl,
  prior_pdf,
  add_set = NULL,
  in_set = NULL,
  w = NULL,
  logZ = 0
)
}
\arguments{
\item{X}{Design matrix}

\item{y}{Binary response vector}

\item{sampl}{Matrix of samples from either the prior (default setting) or from the bridging distribution (partial posterior) formed by the observations in `in_set`}

\item{prior_pdf}{Probability Density Function of the prior. Must only have two arguments, `th` and `di` (a vector or matrix of regression coefficients samples and the number of dimensions of a single sample respectively).}

\item{add_set}{Vector of observation indices to be added to arrive at the desired bridging distribution. If the desired final distribution is the full posterior this should not be specified.}

\item{in_set}{Vector of observation indices already added to give the starting bridging distribution. If the starting 'bridging' distribution is the prior then this should not be specified.}

\item{w}{Vector of weights corresponding to the matrix of samples `sampl`. If not specified all samples are assumed to have equal weight.}

\item{logZ}{Log Bayesian evidence of the partial posterior formed by the observations in `in_set`. Defaults to `0` when `in_set` is not specified.}
}
\value{
A list consisting of; weighted posterior samples (the samples and weights are given in separate lists) and the log Bayesian evidence of the full posterior.
}
\description{
This function uses an iterated batch importance sampling scheme with batch size one to go from one bridging distribution to another. We assume a Bayesian logistic regression model.

The default setting is for the initial 'bridging' distribution to be the prior and the final 'bridging' distribution to be the full posterior.

Used in UNCOVER to generate the log sub-Bayesian evidence of partitioned models, however the weighted samples can also be used for posterior inference.
}
\details{
The default setting is going from prior to full posterior. If using samples from a partial posterior instead of prior samples then `in_set` and `logZ` should be provided. If the samples from the partial posterior are weighted samples then `w` should also be provided. If the full posterior is not the desired output then the specific bridging distribution (partial posterior) required must be specified by the observations wish are to added to the starting partial posterior (i.e. `add_set` is required).

Details of the internal mechanisms of the SMC sampler such as the Metropolis-Hastings MCMC resample move can be found in *UNCOVER paper*
}
\examples{

# First we generate a design matrix X and binary response vector y
DM <- cbind(rep(1,100),matrix(rnorm(200),100,2))
rv <- sample(0:1,100,replace=T)

# We assume the prior for the regression coefficients is a standard normal
pr_fun <- function(th,di){return(dmvn(th,mu=rep(0,di),sigma=diag(di)))}

# Now we can obtain 1000 samples from the posterior using only 1000 samples
# from the prior
out.1 <- MIBIS.Z(X = DM,y = rv,sampl = rmvn(1000,rep(0,3),diag(3)),prior_pdf = pr_fun)
pairs(out.1[[1]])
hist(out.1[[2]])
out.1[[3]]

# If we then added 100 more observations to our data set
DM.2 <- rbind(DM,cbind(rep(1,100),matrix(rnorm(200),100,2)))
rv.2 <- c(rv,sample(0:1,100,replace=T))

# and then wanted samples from the entire posterior instead of starting
# from the prior we can use the previous SMC sampler output
out.2 <- MIBIS.Z(X = DM.2,y = rv.2,sampl = out.1[[1]],prior_pdf = pr_fun,in_set = 1:100,w = out.1[[2]],logZ = out.1[[3]])
pairs(out.2[[1]])
hist(out.2[[2]])
out.2[[3]]

# we can also observe roughly how the particles move when the 100 new
# observations are added in two stages
out.3 <- MIBIS.Z(X = DM.2,y = rv.2,sampl = out.1[[1]],prior_pdf = pr_fun,add_set = 101:150,in_set = 1:100,w = out.1[[2]],logZ = out.1[[3]])
out.4 <- MIBIS.Z(X = DM.2,y = rv.2,sampl = out.3[[1]],prior_pdf = pr_fun,in_set = 1:150,w = out.3[[2]],logZ = out.3[[3]])
pairs(rbind(out.1[[1]],out.3[[1]],out.4[[1]]),col=rep(c('red','green','blue'),each=1000))
}
\keyword{carlo}
\keyword{monte}
\keyword{sequential}
