% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SMC.wrap.R
\name{IBIS.logreg}
\alias{IBIS.logreg}
\title{Logistic regression iterated batch importance sampling}
\usage{
IBIS.logreg(
  X,
  y,
  options = IBIS.logreg.opts(),
  prior_mean = rep(0, ncol(X) + 1),
  prior_var = diag(ncol(X) + 1)
)
}
\arguments{
\item{X}{Covariance matrix}

\item{y}{Binary response vector}

\item{prior}{Name of prior. Can be one of; `"mvn"` for multivariate normal,
`"mvl"` for multivariate laplace or `"mviu"` for multivariate independent
uniform. See details. Defaults to `"mvn"`.}

\item{N}{Number of prior samples. Defaults to 1000.}

\item{ess}{Threshold: if the effective sample size of the particle weights
falls below this value then a resample move step is triggered. Defaults to
`N/2`.}

\item{n_move}{Number of Metropolis-Hastings steps to apply each time a
resample move step is triggered. Defaults to 1.}

\item{weighted}{Should the outputted samples be weighted? As a default the
samples are not weighted.}

\item{...}{Arguments for each of the priors. See details.}
}
\value{
A list consisting of posterior samples and the
log Bayesian evidence of the full posterior. If `weighted==TRUE` the weights
of the samples is also provided.
}
\description{
This function uses an iterated batch importance sampling scheme
with batch size one to go from prior to full posterior. We
assume a Bayesian logistic regression model.
}
\details{
Details of the internal mechanisms of the SMC sampler such as the
Metropolis-Hastings MCMC resample move can be found in *UNCOVER paper* and
Chopin (2002).

When selecting a prior the arguments for said prior must be specified or
default values will be chosen. For a multivariate normal prior, mean `mu`
and covariance matrix `sigma` must be specified or `mu = rep(0,ncol(X)+1)`,
`sigma = diag(ncol(X)+1)` will be selected as default values. For a
multivariate Laplace prior, mean `mu` and covariance matrix `Sigma` must be
specified or `mu = rep(0,ncol(X)+1)`, `Sigma = diag(ncol(X)+1)` will be
selected as default values. For a multivariate independent uniform prior
(i.e. regression coefficients are independent under the prior), a minimum
value vector `a` and a maximum value vector `b` must be specified or
`a = rep(0,ncol(X)+1)`, `b = rep(1,ncol(X)+1)` will be selected as default
values.

Note that decreasing `ess` and increasing `n_move` will lead to a more
accurate estimate of the Bayesian evidence, but at the cost of increased
computational time.
}
\examples{

# First we generate a covariate matrix X and binary response vector y
CM <- matrix(rnorm(200),100,2)
rv <- sample(0:1,100,replace=T)

# Now we can obtain 1000 samples from the posterior from a standard
# multivariate normal prior
out.1 <- IBIS.logreg(X = CM,y = rv)
plot(out.1)
out.1$log_Bayesian_evidence

# We can specify that the samples be weighted
out.1.w <- IBIS.logreg(X = CM,y = rv,options = IBIS.logreg.opts(weighted = TRUE))
out.1.w$weights
plot(out.1.w)

# We can also specify different arguments for a specific prior
out.2 <- IBIS.logreg(X = CM,y = rv,prior_mean = rep(-3,3),prior_var = 0.1*diag(3))
samp.df <- data.frame(rbind(out.1$samples,out.2$samples))
colnames(samp.df) <- paste0("beta[",c(0:2),"]")
ggpairs(samp.df,labeller = "label_parsed",aes(color = as.factor(rep(c(1,2),each=1000))),upper = list(continuous = wrap("density")),lower = list(continuous = wrap("points",size=0.5)))
out.2$log_Bayesian_evidence
out.3 <- IBIS.logreg(X = CM,y = rv,prior_mean = rep(3,3),prior_var = 0.1*diag(3))
samp.df <- data.frame(rbind(out.1$samples,out.2$samples,out.3$samples))
colnames(samp.df) <- paste0("beta[",c(0:2),"]")
ggpairs(samp.df,labeller = "label_parsed",aes(color = as.factor(rep(c(1,2,3),each=1000))),upper = list(continuous = wrap("density")),lower = list(continuous = wrap("points",size=0.5)))
out.3$log_Bayesian_evidence

# We can also change the prior, for example a multivariate independent
# uniform
rmviu <- function(n,a,b){
return(mapply(FUN = function(min.vec,max.vec,pn){runif(pn,a,b)},min.vec=a,max.vec=b,MoreArgs = list(pn = n)))
}
dmviu <- function(x,a,b){
for(ii in 1:ncol(x)){
  x[,ii] <- dunif(x[,ii],a[ii],b[ii])
}
return(apply(x,1,prod))
}

out.4 <- IBIS.logreg(X = CM,y = rv,options = IBIS.logreg.opts(prior.override = TRUE,rprior = rmviu,dprior = dmviu,a=rep(0,3),b=rep(1,3)))
samp.df <- data.frame(rbind(out.1$samples,out.4$samples))
colnames(samp.df) <- paste0("beta[",c(0:2),"]")
ggpairs(samp.df,labeller = "label_parsed",aes(color = as.factor(rep(c(1,4),each=1000))),upper = list(continuous = wrap("density")),lower = list(continuous = wrap("points",size=0.5)))
out.4$log_Bayesian_evidence

}
\references{
Chopin, N. (2002). A sequential particle filter method for
static models. Biometrika, 89(3), 539-552.
}
\keyword{carlo}
\keyword{monte}
\keyword{sequential}
